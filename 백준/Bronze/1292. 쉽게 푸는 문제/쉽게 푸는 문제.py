# 구간A,B 숫자 입력받기
a,b = map(int,input().split())
# 수열을 저장할 리스트 arr
# 처음에 [0]을 넣은 이유는 문제에서 구간을 1번째부터 시작해야 하므로 나중에 인덱스 접근 시 편하게 접근하기 위해
# 리스트의 인덱스가 0부터 시작하기 때문에, 첫번째 숫자가 1부터 시작할 수 있도록 미리 리스트에 0을 넣고 시작
arr=[0]

for i in range(1,b+1):        # 숫자i를 1~b까지 반복
    for j in range(i):        # 숫자 i를 i번 반복해서 arr리스트에 추가(문제 요구가 1을 1번, 2를 2번, 3을 3번...과 같이 반복해서 수열을 생성하는 것)
        arr.append(i)        #i를 1번 반복하여 리스트에 추가

#구간 A에서 B까지의 합 구하기(리스트의 인덱스는 0부터 시작하므로)
# arr의 a번째부터 b번째까지의 값을 추출

print(sum(arr[a-1:b]))        # 더 적절한 표현식_ 파이썬의 0-based indexing을 고려하여 1-based indexing을 보정하는 방식
# print(sum(arr[a:b+1]))




''' 
# 수열 생성을 최소화하는 개선된 버전의 풀이 
# 구간 A, B 숫자 입력받기
a, b = map(int, input().split())

# 수열을 필요한 범위만 만들기
arr = []
i = 1
while len(arr) < b:  # b번째까지 수열을 만들어야 함
    arr.extend([i] * i)  # i를 i번 반복해서 추가)--> extend()사용하여 한번에 리스트를 확장
    i += 1

# 구간 A에서 B까지의 합 구하기
print(sum(arr[a-1:b]))  # a번째부터 b번째까지 합 (a-1 인덱스 맞추기)
# 슬라이싱 시 a-1:b로 범위를 지정해 구간의 합을 구함 --> 문제에서 요구한 구간이 1번째부터 시작하므로, 파이썬 리스트 인덱스를 맞추기 위해 a-1을 사용
입력: a = 3, b = 7

arr[a:b+1]:
arr[3:8]을 의미. 이는 3번째부터 8번째 요소까지를 의미하며, 파이썬의 0-based indexing에서 arr[2]부터 시작해야 하는데, 이렇게 되면 잘못된 구간이 됩니다.
arr[a-1:b]:
arr[2:7]을 의미, 정확히 3번째부터 7번째 요소까지 구간을 가져옵니다.
따라서, 이 문제에서 구간이 1-based로 주어졌기 때문에, 이를 맞추기 위해서 인덱스를 1 줄여서 **arr[a-1:b]**를 사용하는 것이 적절!


'''
